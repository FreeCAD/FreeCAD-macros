# ScatterObjectsOnSurface.FCMacro
#
# Description:
# This macro allows the user to scatter a selected object (scatter object) across the
# surfaces of another object (base object) or any selected faces. It supports random
# rotation (about local Z axis), minimum spacing to prevent overlaps, and ensures objects remain on the
# actual face geometry, avoiding holes or floating placements (I hope!).
#
# Usage:
# 1. Select the base object or specific faces in the 3D view.
# 2. Select the scatter object (the object to distribute).
# 3. Run the macro via the Macro manager or Python console.
# 4. Configure as required (see below for options)
#
# The scattered objects will be combined into a single compound named 'ScatteredCompound'
#
# GUI and CLI Parameters:
#
# | Parameter                 | Type        | Description                                                                                  | Default |
# |---------------------------|-------------|----------------------------------------------------------------------------------------------|---------|
# | density                   | float       | Approximate number of points per mm² on the surface                                          | 0.05    |
# | min_spacing               | float       | Minimum distance between scatter objects in mm (0 = auto based on bounding box)              | 0.0     |
# | random_rotation           | bool        | Apply random rotation around the surface normal                                              | True    |
# | cross_side_spacing        | bool        | Prevent overlaps across opposite-facing surfaces                                             | False   |
# | seed                      | int/None    | Optional random seed for reproducible scatter patterns                                       | None    |
# | faces                     | list        | List of Part.Face objects to scatter on (CLI) or selected in GUI                             | All faces if not provided |
# | base_shape                | Part.Shape  | Shape of the base object for collision checks                                                | Required|

__Name__ = "Scatter Objects on Surface"
__Comment__ = "Distribute objects randomly over surfaces of another object with spacing and rotation options."
__Author__ = "Sam Hutchinson (flightmansam)"
__Date__ = "2025-08-15"
__Version__ = "1.1.0"
__License__ = "LGPL-2.0-or-later"
__Web__ = "https://github.com/FreeCAD/FreeCAD-macros"
__Wiki__ = "https://wiki.freecad.org/ScatterObjectsOnSurface"
__Icon__ = "ScatterObjectsOnSurface.png"
__Help__ = "Select base object (or faces) first, then scatter object, and run the macro."
__Status__ = "Beta"
__Requires__ = "FreeCAD >= 1.0"
__Communication__ = "https://github.com/FreeCAD/FreeCAD-macros/issues/"
__Files__ = "ScatterObjectsOnSurface.png"

import math
import random
from typing import Iterable

import FreeCAD as app
import FreeCADGui as gui
import Part  # FreeCAD.
from PySide import QtWidgets  # ! FreeCAD's PySide, can be PySide2 or PySide6 depending on version.

CellKey = tuple[int, int, int]
VecPair = tuple[app.Vector, app.Vector]
GridMap = dict[CellKey, list[VecPair]]


def _grid_key(p: app.Vector, cell: float) -> CellKey:
    return (
        int(math.floor(p.x / cell)),
        int(math.floor(p.y / cell)),
        int(math.floor(p.z / cell)),
    )


def _neighbor_keys(k: CellKey) -> Iterable[CellKey]:
    x, y, z = k
    for dx in (-1, 0, 1):
        for dy in (-1, 0, 1):
            for dz in (-1, 0, 1):
                yield (x + dx, y + dy, z + dz)


def _too_close_grid(
    candidate_pt: app.Vector,
    candidate_n: app.Vector,
    grid: GridMap,
    cell: float,
    min_spacing: float,
    cross_side_spacing: bool,
) -> bool:
    """Check only local neighbourhood cells; grid maps cell_key -> list[(pt, n)]."""
    key = _grid_key(candidate_pt, cell)
    for nk in _neighbor_keys(key):
        for p, n in grid.get(nk, ()):
            if not cross_side_spacing and n.dot(candidate_n) < 0:
                continue
            if candidate_pt.distanceToPoint(p) < min_spacing:
                return True
    return False


def _halton(i: int, b: int) -> float:
    f, r = 1.0, 0.0
    while i > 0:
        f /= b
        r += f * (i % b)
        i //= b
    return r


# --------------------------------
# Main scatter logic
# --------------------------------

def scatter_on_faces(
    faces: list[Part.Face],
    scatter_shape: Part.Shape,
    density: float = 0.01,
    min_spacing: float | None = None,
    random_rotation: bool = True,
    seed: int | None = None,
    cross_side_spacing: bool = False,
    base_shape: Part.Shape | None = None,
) -> app.DocumentObject | None:
    """
    Scatter copies of scatter_shape over the given faces.

    Returns:
        The created document object (Part::Feature) containing the compound,
        or None if nothing was generated.
    """
    if seed is not None:
        random.seed(seed)

    doc: app.Document = app.ActiveDocument
    scattered_shapes: list[Part.Shape] = []

    # Auto spacing from scatter object's size if none given
    if not min_spacing or min_spacing <= 0:
        bbox = scatter_shape.BoundBox
        min_spacing = bbox.DiagonalLength * 1.1

    # Spatial hash grid for very fast spacing checks
    grid: GridMap = {}
    cell: float = max(min_spacing * 5, 1e-6)

    for face in faces:
        target: int = max(1, int(face.Area * density))
        tries: int = 0
        placed_on_face: int = 0
        max_tries: int = max(200, target * 40)

        # parameter ranges
        u_min, u_max, v_min, v_max = face.ParameterRange

        # Halton sequence index (per face)
        idx: int = 0

        while placed_on_face < target and tries < max_tries:
            tries += 1
            idx += 1

            hu: float = _halton(idx, 2)
            hv: float = _halton(idx, 3)
            u: float = u_min + hu * (u_max - u_min)
            # explicit form kept
            v: float = v_min + hv * (v_max - v_min)

            pt: app.Vector = face.valueAt(u, v)

            # Must lie on the actual face area (excludes holes / outside UV)
            if not face.isInside(pt, 1e-2, False):
                continue

            n: app.Vector = face.normalAt(u, v)
            if n.Length == 0:
                continue
            n = n.normalize()

            # Spacing check via spatial grid
            if _too_close_grid(pt, n, grid, cell, float(min_spacing), cross_side_spacing):
                continue

            # Align +Z to the surface normal (handles 180° case)
            placement = app.Placement()
            placement.Base = pt
            placement.Rotation = app.Rotation(app.Vector(0, 0, 1), n)

            # Optional random spin around the (now aligned) local Z / surface normal
            if random_rotation:
                placement.Rotation = app.Rotation(n, random.uniform(0, 360)).multiply(
                    placement.Rotation
                )

            inst: Part.Shape = scatter_shape.copy()
            inst.Placement = placement

            # Collision check: only keep if not buried in unselected geometry
            if base_shape:
                test_pt: app.Vector = pt + n.multiply(0.1)  # 0.1 mm above surface
                if base_shape.isInside(test_pt, 1e-6, True):
                    continue

            scattered_shapes.append(inst)

            # Insert into spatial grid
            k: CellKey = _grid_key(pt, cell)
            grid.setdefault(k, []).append((pt, n))

            placed_on_face += 1

    if not scattered_shapes:
        app.Console.PrintMessage("No shapes generated.\n")
        return None

    compound: Part.Shape = Part.makeCompound(scattered_shapes)
    obj = doc.addObject("Part::Feature", "ScatteredCompound")
    obj.Shape = compound
    doc.recompute()
    return obj


# ---------------------------
# GUI
# ---------------------------

def run_scatter_dialog() -> None:
    # preferences bucket for this macro
    prefs: app.ParamGet = app.ParamGet("User parameter:BaseApp/Preferences/Macros/ScatterObjectsOnSurface")

    sel = gui.Selection.getSelectionEx()
    if len(sel) < 2:
        app.Console.PrintError("Select base object (or faces) first, then scatter object.\n")
        return

    base_sel = sel[0]
    scatter_obj = sel[1].Object
    scatter_shape: Part.Shape = scatter_obj.Shape

    faces: list[Part.Face] = [sub for sub in base_sel.SubObjects if isinstance(sub, Part.Face)]
    base_shape: Part.Shape = base_sel.Object.Shape

    if not faces:
        try:
            faces = base_shape.Faces
        except Exception:
            app.Console.PrintError("First selection must be a Part/Body with faces (or select faces directly).\n")
            return

    dlg = QtWidgets.QDialog()
    dlg.setWindowTitle("Scatter Objects on Surface")
    layout = QtWidgets.QFormLayout(dlg)

    # Load last-used values (with sensible defaults)
    last_density: float = prefs.GetFloat("density", 0.05)
    last_spacing: float = prefs.GetFloat("min_spacing", 0.0)
    last_randrot: bool = prefs.GetBool("random_rotation", True)
    last_crossside: bool = prefs.GetBool("cross_side_spacing", False)
    last_seed: int = prefs.GetInt("seed", 0)

    density_spin = QtWidgets.QDoubleSpinBox()
    density_spin.setRange(0.0001, 100.0)
    density_spin.setDecimals(4)
    density_spin.setValue(last_density)
    layout.addRow("Density (points per mm²):", density_spin)

    spacing_spin = QtWidgets.QDoubleSpinBox()
    spacing_spin.setRange(0.0, 1000.0)
    spacing_spin.setDecimals(3)
    spacing_spin.setValue(last_spacing)
    layout.addRow("Min spacing (mm):", spacing_spin)

    randrot_chk = QtWidgets.QCheckBox()
    randrot_chk.setChecked(last_randrot)
    layout.addRow("Random rotation:", randrot_chk)

    crossside_chk = QtWidgets.QCheckBox()
    crossside_chk.setChecked(last_crossside)
    layout.addRow("Spacing across opposite sides:", crossside_chk)

    seed_spin = QtWidgets.QSpinBox()
    seed_spin.setRange(0, 999999)
    seed_spin.setValue(last_seed)
    layout.addRow("Random seed (0 = none):", seed_spin)

    btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
    layout.addRow(btns)

    def on_accept() -> None:
        density: float = density_spin.value()
        spacing: float = spacing_spin.value()
        random_rotation: bool = randrot_chk.isChecked()
        cross_side_spacing: bool = crossside_chk.isChecked()
        seed_val: int = seed_spin.value()
        seed: int | None = seed_val if seed_val != 0 else None

        # Save choices for next time
        prefs.SetFloat("density", float(density))
        prefs.SetFloat("min_spacing", float(spacing))
        prefs.SetBool("random_rotation", bool(random_rotation))
        prefs.SetBool("cross_side_spacing", bool(cross_side_spacing))
        prefs.SetInt("seed", int(seed_val if seed is not None else 0))

        doc: App.Document = App.ActiveDocument
        doc.openTransaction("ScatterObjectsOnSurface")
        try:
            scatter_on_faces(
                faces=faces,
                scatter_shape=scatter_shape,
                density=density,
                min_spacing=spacing,
                random_rotation=random_rotation,
                seed=seed,
                cross_side_spacing=cross_side_spacing,
                base_shape=base_shape,
            )
        except Exception:
            doc.abortTransaction()
            raise
        else:
            doc.commitTransaction()

        dlg.accept()

    btns.accepted.connect(on_accept)
    btns.rejected.connect(dlg.reject)

    dlg.exec()


# Run from active FreeCAD document
run_scatter_dialog()

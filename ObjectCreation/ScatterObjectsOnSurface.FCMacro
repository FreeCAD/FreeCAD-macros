# ScatterObjectsOnSurface.FCMacro
#
# Description:
# This macro allows the user to scatter a selected object (scatter object) across the
# surfaces of another object (base object) or any selected faces. It supports random
# rotation (about local Z axis), minimum spacing to prevent overlaps, and ensures objects remain on the
# actual face geometry, avoiding holes or floating placements (I hope!).
#
# Usage:
# 1. Select the base object or specific faces in the 3D view.
# 2. Select the scatter object (the object to distribute).
# 3. Run the macro via the Macro manager or Python console.
# 4. Configure as required (see below for options)
#
# The scattered objects will be combined into a single compound named 'ScatteredCompound'
#
# GUI and CLI Parameters:
#
# | Parameter                 | Type        | Description                                                                                  | Default |
# |---------------------------|-------------|----------------------------------------------------------------------------------------------|---------|
# | density                   | float       | Approximate number of points per mm² on the surface                                          | 0.05    |
# | min_spacing               | float       | Minimum distance between scatter objects in mm (0 = auto based on bounding box)              | 0.0     |
# | random_rotation           | bool        | Apply random rotation around the surface normal                                              | True    |
# | cross_side_spacing        | bool        | Prevent overlaps across opposite-facing surfaces                                             | False   |
# | seed                      | int/None    | Optional random seed for reproducible scatter patterns                                       | None    |
# | faces                     | list        | List of Part.Face objects to scatter on (CLI) or selected in GUI                             | All faces if not provided |
# | base_shape                | Part.Shape  | Shape of the base object for collision checks                                                | Required|

__Name__ = "Scatter Objects on Surface"
__Comment__ = "Distribute objects randomly over surfaces of another object with spacing and rotation options."
__Author__ = "Sam Hutchinson (flightmansam)"
__Date__ = "2025-08-15"
__Version__ = "1.1"  # grid + Halton speedup + saved prefs
__License__ = "LGPL-2.0-or-later"
__Web__ = "https://github.com/FreeCAD/FreeCAD-macros"
__Wiki__ = "https://wiki.freecad.org/ScatterObjectsOnSurface"
__Icon__ = "ScatterObjectsOnSurface.png"
__Help__ = "Select base object (or faces) first, then scatter object, and run the macro."
__Status__ = "Beta"
__Requires__ = "FreeCAD >= 1.0"
__Communication__ = "https://github.com/FreeCAD/FreeCAD-macros/issues/"
__Files__ = "ScatterObjectsOnSurface.png"

import FreeCAD as App
import FreeCADGui as Gui
import Part
import random
import math
from PySide import QtWidgets


# Spatial hashing

def _grid_key(p: App.Vector, cell: float):
    return (int(math.floor(p.x / cell)),
            int(math.floor(p.y / cell)),
            int(math.floor(p.z / cell)))

def _neighbor_keys(k):
    x, y, z = k
    for dx in (-1, 0, 1):
        for dy in (-1, 0, 1):
            for dz in (-1, 0, 1):
                yield (x + dx, y + dy, z + dz)

def _too_close_grid(candidate_pt, candidate_n, grid, cell, min_spacing, cross_side_spacing):
    """Check only local neighbourhood cells; grid maps cell_key -> list[(pt, n)]."""
    key = _grid_key(candidate_pt, cell)
    for nk in _neighbor_keys(key):
        for p, n in grid.get(nk, ()):
            if not cross_side_spacing and n.dot(candidate_n) < 0:
                continue
            if candidate_pt.distanceToPoint(p) < min_spacing:
                return True
    return False

def _halton(i, b):
    f, r = 1.0, 0.0
    while i > 0:
        f /= b
        r += f * (i % b)
        i //= b
    return r

def scatter_on_faces(
    faces,
    scatter_shape,
    density=0.01,
    min_spacing=None,
    random_rotation=True,
    seed=None,
    cross_side_spacing=False,
    base_shape=None
):
    if seed is not None:
        random.seed(seed)

    doc = App.ActiveDocument
    scattered_shapes = []

    # Auto spacing from scatter object's size if none given
    if not min_spacing or min_spacing <= 0:
        bbox = scatter_shape.BoundBox
        min_spacing = bbox.DiagonalLength * 1.1

    # Spatial hash grid for very fast spacing checks
    grid = {}
    cell = max(min_spacing*5, 1e-6)

    for face in faces:
        target = max(1, int(face.Area * density))
        tries = 0
        placed_on_face = 0
        max_tries = max(200, target * 40)

        # parameter ranges
        u_min, u_max, v_min, v_max = face.ParameterRange

        # Halton sequence index (per face)
        idx = 0

        while placed_on_face < target and tries < max_tries:
            tries += 1
            idx += 1

            hu = _halton(idx, 2)
            hv = _halton(idx, 3)
            u = u_min + hu * (u_max - u_min)
            v = v_min + hv * (v_max - v_max) if False else v_min + hv * (v_max - v_min)  # keep explicit

            pt = face.valueAt(u, v)

            # Must lie on the actual face area (excludes holes / outside UV)
            if not face.isInside(pt, 1e-2, False):
                continue

            n = face.normalAt(u, v)
            if n.Length == 0:
                continue
            n = n.normalize()

            # Spacing check via spatial grid
            if _too_close_grid(pt, n, grid, cell, min_spacing, cross_side_spacing):
                continue

            # Align +Z to the surface normal (handles 180° case)
            placement = App.Placement()
            placement.Base = pt
            placement.Rotation = App.Rotation(App.Vector(0, 0, 1), n)

            # Optional random spin around the (now aligned) local Z / surface normal
            if random_rotation:
                placement.Rotation = App.Rotation(n, random.uniform(0, 360)).multiply(placement.Rotation)

            inst = scatter_shape.copy()
            inst.Placement = placement

            # Collision check: only keep if not buried in unselected geometry
            if base_shape:
                test_pt = pt + n.multiply(0.1)  # 0.1 mm above surface
                if base_shape.isInside(test_pt, 1e-6, True):
                    continue

            scattered_shapes.append(inst)

            # Insert into spatial grid
            k = _grid_key(pt, cell)
            grid.setdefault(k, []).append((pt, n))

            placed_on_face += 1

    if not scattered_shapes:
        App.Console.PrintMessage("No shapes generated.\n")
        return None

    compound = Part.makeCompound(scattered_shapes)
    obj = doc.addObject("Part::Feature", "ScatteredCompound")
    obj.Shape = compound
    doc.recompute()
    return obj

# ---------------------------
# GUI
# ---------------------------

def run_scatter_dialog():
    # preferences bucket for this macro
    prefs = App.ParamGet("User parameter:BaseApp/Preferences/Macros/ScatterObjectsOnSurface")

    sel = Gui.Selection.getSelectionEx()
    if len(sel) < 2:
        App.Console.PrintError("Select base object (or faces) first, then scatter object.\n")
        return

    base_sel = sel[0]
    scatter_obj = sel[1].Object
    scatter_shape = scatter_obj.Shape

    faces = [sub for sub in base_sel.SubObjects if isinstance(sub, Part.Face)]
    base_shape = base_sel.Object.Shape

    if not faces:
        try:
            faces = base_shape.Faces
        except Exception:
            App.Console.PrintError("First selection must be a Part/Body with faces (or select faces directly).\n")
            return

    dlg = QtWidgets.QDialog()
    dlg.setWindowTitle("Scatter Objects on Surface")
    layout = QtWidgets.QFormLayout(dlg)

    # Load last-used values (with sensible defaults)
    last_density = prefs.GetFloat("density", 0.05)
    last_spacing = prefs.GetFloat("min_spacing", 0.0)
    last_randrot = prefs.GetBool("random_rotation", True)
    last_crossside = prefs.GetBool("cross_side_spacing", False)
    last_seed = prefs.GetInt("seed", 0)

    density_spin = QtWidgets.QDoubleSpinBox()
    density_spin.setRange(0.0001, 100.0)
    density_spin.setDecimals(4)
    density_spin.setValue(last_density)
    layout.addRow("Density (points per mm²):", density_spin)

    spacing_spin = QtWidgets.QDoubleSpinBox()
    spacing_spin.setRange(0.0, 1000.0)
    spacing_spin.setDecimals(3)
    spacing_spin.setValue(last_spacing)
    layout.addRow("Min spacing (mm):", spacing_spin)

    randrot_chk = QtWidgets.QCheckBox()
    randrot_chk.setChecked(last_randrot)
    layout.addRow("Random rotation:", randrot_chk)

    crossside_chk = QtWidgets.QCheckBox()
    crossside_chk.setChecked(last_crossside)
    layout.addRow("Spacing across opposite sides:", crossside_chk)

    seed_spin = QtWidgets.QSpinBox()
    seed_spin.setRange(0, 999999)
    seed_spin.setValue(last_seed)
    layout.addRow("Random seed (0 = none):", seed_spin)

    btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
    layout.addRow(btns)

    def on_accept():
        density = density_spin.value()
        spacing = spacing_spin.value()
        random_rotation = randrot_chk.isChecked()
        cross_side_spacing = crossside_chk.isChecked()
        seed = seed_spin.value() if seed_spin.value() != 0 else None

        # Save choices for next time
        prefs.SetFloat("density", float(density))
        prefs.SetFloat("min_spacing", float(spacing))
        prefs.SetBool("random_rotation", bool(random_rotation))
        prefs.SetBool("cross_side_spacing", bool(cross_side_spacing))
        prefs.SetInt("seed", int(seed_spin.value() if seed is not None else 0))

        doc = App.ActiveDocument
        doc.openTransaction("ScatterObjectsOnSurface")
        try:
            scatter_on_faces(
                faces=faces,
                scatter_shape=scatter_shape,
                density=density,
                min_spacing=spacing,
                random_rotation=random_rotation,
                seed=seed,
                cross_side_spacing=cross_side_spacing,
                base_shape=base_shape
            )
        except Exception:
            doc.abortTransaction()
            raise
        else:
            doc.commitTransaction()

        dlg.accept()

    btns.accepted.connect(on_accept)
    btns.rejected.connect(dlg.reject)

    dlg.exec()


# Run from active FreeCAD document
run_scatter_dialog()

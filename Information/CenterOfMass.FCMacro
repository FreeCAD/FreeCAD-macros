#!/usr/bin/env python
# coding: utf-8
#
# Compute and show the center of mass for multiple solids
#
# Usage:
# 1. Select one or multiple solids.
# 2. Launch the macro.
# 3. You'll have a window listing the solids. You can put the density of your
#    material in different unit systems or choose from predefined materials.
#
# Options:
# * Color the solids according to density.
# * Display where is the center of mass.
# * Export and import densities (even if it's not a .csv file from the macro,
#  as soon as there is a column named "Density").
# * Save densities in the document (remove them again when setting material
#  to "default")
#
# Credits:
# 2018 - present: schupin
# 2022 - present: SyProLei project (Saarland University)
#

__Name__ = 'CenterOfMass'
__Comment__ = 'Compute and show the center of mass for multiple solids'
__Author__ = 'chupins, s-quirin'
__Version__ = '0.5.8'
__Date__ = '2022-04-13'
__License__ = 'LGPL-3.0-or-later'
__Web__ = 'https://forum.freecadweb.org/viewtopic.php?f=24&t=31883'
__Wiki__ = 'https://www.freecadweb.org/wiki/Macro_CenterOfMass'
__Icon__ = 'https://www.freecadweb.org/wiki/images/d/d7/Centomass.png'
__Help__ = 'Select one or more bodies and launch'
__Status__ = 'Alpha'
__Requires__ = 'FreeCAD >= 0.19'
__Communication__ = 'https://forum.freecadweb.org/viewtopic.php?f=24&t=31883'
__Files__ = ''

# Todo:
# - resetting stylesheet of QDoubleSpinBox
# - error with draft array of meshes (relevant?)
# - App:Link lacks the .getGlobalPlacement() method and childShapes() do not equal,
# so .InListRecursive and .OutList is used as a workaround.
# @realthunder proposes https://forum.freecadweb.org/viewtopic.php?p=569083#p569083
# Ideas:
# - moments of inertia with arrows that allow the user to see the relative magnitudes

import csv
import os
import math

from PySide import QtCore, QtGui    # FreeCAD's PySide!

import FreeCAD as app
import FreeCADGui as gui
from FreeCAD import Units

# Preferences
DEFAULT_DENSITY = '2500 kg/m^3'
MAXIMUM_DENSITY = '25000 kg/m^3'    # maximum physically meaningful value
DOCKED_WINDOW = True    # False: floating window
SORT_SELECTION = False
DEFAULT_COLORMAP = 'coolwarm'

# FreeCAD Preferences (Tools -> Edit Parameters), 2nd parameter of .GetX
# is the default value
MACRO_SETTINGS  = 'User parameter:BaseApp/Preferences/Macros/' + __Name__
DEFAULT_DENSITY = app.ParamGet(MACRO_SETTINGS).GetString('Default density', '2500 kg/m^3')
DOCKED_WINDOW   = app.ParamGet(MACRO_SETTINGS).GetBool('Docked window', True)    # False: floating
SORT_SELECTION  = app.ParamGet(MACRO_SETTINGS).GetBool('Sort selection', False)
DEFAULT_COLORMAP  = app.ParamGet(MACRO_SETTINGS).GetString('Default colormap', 'coolwarm')
GUI_FONT_SIZE   = app.ParamGet('User parameter:BaseApp/Preferences/Editor').GetInt('FontSize', 10)
GUI_ICON_SIZE   = app.ParamGet('User parameter:BaseApp/Preferences/General').GetInt('ToolbarIconSize', 24)

# Floating window size preferences: fraction of primary screen's size
WINDOW_WIDTH = int(0.2 * QtGui.QGuiApplication.screens()[0].geometry().width())
WINDOW_HEIGHT = int(0.5 * QtGui.QGuiApplication.screens()[0].geometry().height())

app.ParamGet(MACRO_SETTINGS).SetString('Default density', DEFAULT_DENSITY)
app.ParamGet(MACRO_SETTINGS).SetBool('Docked window', DOCKED_WINDOW)
app.ParamGet(MACRO_SETTINGS).SetBool('Sort selection', SORT_SELECTION)
app.ParamGet(MACRO_SETTINGS).SetString('Sort selection', DEFAULT_COLORMAP)
g_main_window = gui.getMainWindow()
g_font = gui.getMainWindow().font()
g_font.setPointSize(GUI_FONT_SIZE)
g_font_metrics = QtGui.QFontMetrics(g_font)
g_str_width1 = g_font_metrics.horizontalAdvance('0_000e+00')
g_str_width2 = g_font_metrics.horizontalAdvance('_0_000e+00_')
g_icon_size = QtCore.QSize(GUI_ICON_SIZE, GUI_ICON_SIZE)
g_relative_radius = 'mass'
g_sel = []    # the list of selected objects


class CenterofmassDock(QtGui.QDockWidget):
    """if DOCKED_WINDOW = True"""
    def __init__(self):
        super().__init__()
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose, True)    # free memory
        self.child = CenterofmassWidget(self)
        self.setWidget(self.child)
        g_main_window.addDockWidget(QtCore.Qt.RightDockWidgetArea, self)


class CenterofmassWindow(QtGui.QMainWindow):
    """if DOCKED_WINDOW = False"""
    def __init__(self, parent=g_main_window):
        super().__init__(parent)    # parent: Window stays on top
        self.child = CenterofmassWidget(self)
        self.setCentralWidget(self.child)
        self.set_position()
        self.show()

    def set_position(self):
        """Set a sensible default position for the window.
        With FreeCAD's default layout, this will be over the Combo View.
        """
        geom = g_main_window.geometry()
        xpos = geom.left() + 50
        ypos = geom.center().y() - WINDOW_HEIGHT // 2
        self.setGeometry(xpos, ypos, WINDOW_WIDTH, WINDOW_HEIGHT)


class SolidsWidget():
    """Rows in scroll area"""
    def __init__(self, parent, solid, sol):
        self.parent = parent
        self.sol = sol
        color = solid.ViewObject.ShapeColor
        self.orgColorFC = color
        self.orgColorQT = QtGui.QColor.fromRgbF(*color)
        self.orgTransparency = solid.ViewObject.Transparency
        self.labelC = QtGui.QLabel(' ', parent)
        self.label = QtGui.QLabel(solid.Label, parent)
        self.combo = QtGui.QComboBox(parent)
        self.spinDens = QtGui.QDoubleSpinBox(parent)
        self.spinMass = QtGui.QLineEdit(parent)

        # init properties
        self.labelC.setStyleSheet(
            'QLabel {background-color: %s}' % self.orgColorQT.name())
        self.labelC.setMaximumWidth(GUI_ICON_SIZE)
        self.combo.addItem('custom')
        for m in parent.material_base:
            self.combo.addItem(m)
        mat_name = getattr(g_sel[sol], 'Mat_Name', 'default')
        mat_density = getattr(g_sel[sol], 'Mat_Density', parent.material_base['default'])
        if hasattr(g_sel[sol], 'Material'):
            if hasattr(g_sel[sol].Material, 'Material'):
                # overwrite if Arch Material set
                mat_name = g_sel[sol].Material.Material['CardName']
                mat_density = g_sel[sol].Material.Material['Density']
        self.combo.setCurrentText(mat_name)    # not found: stays 0=custom
        self.combo.currentIndexChanged.connect(self.on_comboMaterial_changed)
        self.init_spinDensity(self.spinDens, Units.Quantity(mat_density), parent.unitForD)
        self.spinDens.setToolTip(
            'density of ' + solid.Label + ' (in ' + parent.unitForD_text + ')')
        self.spinDens.valueChanged.connect(self.on_spinDensity_changed)
        self.spinMass.setReadOnly(True)
        self.spinMass.setAlignment(QtCore.Qt.AlignCenter)
        self.spinMass.setMinimumWidth(g_str_width1)
        self.spinMass.setMaximumWidth(g_str_width2)
        self.update_spinMass_only()

        # layout grid
        if sol == 0:
            label02 = QtGui.QLabel('Material', parent)
            label03 = QtGui.QLabel('Density', parent)
            label04 = QtGui.QLabel('Mass', parent)
            parent.solidLayout.addWidget(label02, sol, 2)
            parent.solidLayout.addWidget(label03, sol, 3)
            parent.solidLayout.addWidget(label04, sol, 4)
        parent.solidLayout.addWidget(self.labelC, sol+1, 0)
        parent.solidLayout.addWidget(self.label, sol+1, 1)
        parent.solidLayout.addWidget(self.combo, sol+1, 2)
        parent.solidLayout.addWidget(self.spinDens, sol+1, 3)
        parent.solidLayout.addWidget(self.spinMass, sol+1, 4)

    def init_spinDensity(self, spin, qty, unitForD):
        spinBoxDigits = 6
        # don't trigger on_spinDensity_changed (e.g. when on_comboUnitDensity_changed)
        spin.blockSignals(True)
        spin.setMaximum(Units.Quantity(MAXIMUM_DENSITY).getValueAs(unitForD))
        decimals = spinBoxDigits - math.floor(math.fabs(math.log10(spin.maximum())))
        spin.setMinimum(math.pow(10, -decimals))
        spin.setDecimals(decimals)
        spin.setStepType(QtGui.QAbstractSpinBox.StepType.AdaptiveDecimalStepType)
        spin.setValue(qty.getValueAs(unitForD))
        spin.blockSignals(False)

    def on_spinDensity_changed(self):
        self.combo.setCurrentIndex(0)    # set to custom
        self.parent.compute_centerOfMass()
        self.update_spinMass_only()

    def update_spinMass_only(self):
        parent = self.parent
        volumeInUnit = parent.convert_volume(parent.volumes[self.sol])
        value = volumeInUnit * self.spinDens.value()
        self.spinMass.setText(format(value, '.3e'))
        self.spinMass.setToolTip(
            'mass of ' + self.label.text() + ' (in ' + parent.unitForM + ')')

    def on_comboMaterial_changed(self, newIndex):
        materialName = self.combo.currentText()
        qty = self.parent.material_base.get(materialName, 0)
        if qty:
            materialDensity = Units.Quantity(qty).getValueAs(self.parent.unitForD)
            self.spinDens.blockSignals(True)
            # don't trigger on_spinDensity_changed
            self.spinDens.setValue(materialDensity)
            self.spinDens.blockSignals(False)
            self.parent.compute_centerOfMass()
            self.update_spinMass_only()


class CenterofmassWidget(QtGui.QWidget):
    """This is the widget which does almost all of the work.
    Widgets don't have close boxes, so closing is dealt with in
    CenterofmassWindow."""
    def __init__(self, parent):
        super().__init__(parent)
        self.setObjectName(__Name__)
        parent.setWindowTitle(__Name__ + ' ' + __Version__)
        parent.setFont(g_font)
        self.doc = app.activeDocument()
        self.material_base = {}
        self.solid_count = 0
        objs = self.valid_selection()
        self.init_UI()
        if self.solid_count <= 0:
            self.setDisabled(True)
            self.startup_dialog()
        else:
            self.init_solids(objs)

    def startup_dialog(self):
        """Error dialog allowing a new selection"""
        msg = 'Select a valid object (a solid or a mesh) first.'
        app.Console.PrintError(msg + '\n')
        diag = QtGui.QMessageBox(QtGui.QMessageBox.Critical, 'Error', msg, parent=g_main_window)
        diag.setModal(False)
        diag.setStandardButtons(QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel)
        diag.finished.connect(self.on_startup_dialog_finished)
        diag.show()

    def on_startup_dialog_finished(self, result):
        if result == QtGui.QMessageBox.Ok:
            objs = self.valid_selection()
            if self.solid_count <= 0:
                self.startup_dialog()
            else:
                self.init_solids(objs)
                self.setDisabled(False)
        else:
            self.parentWidget().close()

    def init_UI(self):
        """Lay out the interactive elements"""
        # main layout
        layout = QtGui.QVBoxLayout(self)

        # titleLayout
        toPreferences = QtGui.QPushButton(QtGui.QIcon(':/icons/Std_DlgParameter.svg'),'')
        toPreferences.setToolTip('Preferences -> Macros')
        toPreferences.clicked.connect(self.on_pushButton_toPreferences)

        label_comboUnit = QtGui.QLabel('Density:')
        label_comboUnit.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        comboUnitDensity = QtGui.QComboBox(toolTip='Unit of density')
        comboUnitDensity.addItems(['kg/m^3',
                                   'g/dm^3', 'g/cm^3',
                                   'mg/mm^3',
                                   'oz/in^3',
                                   'lb/in^3', 'lb/ft^3', 'lb/yd^3'])
        comboUnitDensity.currentTextChanged.connect(self.on_comboUnitDensity_changed)
        # Get units set as preference
        self.store_prefered_units(comboUnitDensity.currentText())

        label_defaultDensity = QtGui.QLabel('Default Density:')
        label_defaultDensity.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.defaultDensitySpin = QtGui.QDoubleSpinBox(self)
        SolidsWidget.init_spinDensity(self,
                                      self.defaultDensitySpin,
                                      Units.Quantity(DEFAULT_DENSITY),
                                      self.unitForD)
        self.defaultDensitySpin.setToolTip(
            'set default density (in ' + self.unitForD_text + ')')
        self.defaultDensitySpin.valueChanged.connect(self.on_spinDefaultDensity_changed)
        self.material_base['default'] = Units.Quantity(DEFAULT_DENSITY)

        allToDefaultDensity = QtGui.QPushButton('Apply to all')
        allToDefaultDensity.setToolTip('Set all solids to default density')
        allToDefaultDensity.clicked.connect(self.on_pushButton_allToDefaultDensity)

        titleLayoutBox = QtGui.QGroupBox('Preferences')
        titleLayout = QtGui.QHBoxLayout()
        titleLayout.addWidget(toPreferences)
        titleLayout.addWidget(label_comboUnit)
        titleLayout.addWidget(comboUnitDensity)
        titleLayout.addSpacing(GUI_FONT_SIZE)
        titleLayout.addWidget(label_defaultDensity)
        titleLayout.addWidget(self.defaultDensitySpin)
        titleLayout.addWidget(allToDefaultDensity)
        titleLayoutBox.setLayout(titleLayout)
        layout.addWidget(titleLayoutBox)

        # solidGroupBox
        self.load_materials()    # load material cards
        self.solidLayout = QtGui.QGridLayout()
        solidGroupBox = QtGui.QGroupBox()
        solidGroupBox.setFlat(True)
        solidGroupBox.setLayout(self.solidLayout)
        scroll = QtGui.QScrollArea()
        scroll.setWidget(solidGroupBox)
        scroll.setWidgetResizable(True)

        # buttonGroupBox
        newSelection = QtGui.QPushButton('Update')
        newSelection.setToolTip('Get solids from selection')
        newSelection.setIcon(QtGui.QIcon(':/icons/LinkSelect.svg'))
        newSelection.setIconSize(g_icon_size)
        newSelection.clicked.connect(self.on_pushButton_newSelection)

        save = QtGui.QPushButton('Save')
        save.setToolTip('Save material property in document objects')
        save.setIcon(QtGui.QIcon(':/icons/document-save.svg'))
        save.setIconSize(g_icon_size)
        save.clicked.connect(self.on_pushButton_Save)

        export = QtGui.QPushButton('Export')
        export.setToolTip('Export values to a .csv file')
        export.setIcon(QtGui.QIcon(':/icons/Std_SaveCopy.svg'))
        export.setIconSize(g_icon_size)
        export.clicked.connect(self.on_pushButton_Export)

        readDensities = QtGui.QPushButton('Import')
        readDensities.setToolTip('Import densities from a .csv file')
        readDensities.setIcon(QtGui.QIcon(':/icons/Std_Import.svg'))
        readDensities.setIconSize(g_icon_size)
        readDensities.clicked.connect(self.on_pushButton_Import)

        editMaterial = QtGui.QPushButton('Materials')
        editMaterial.setToolTip('Edit Material list')
        editMaterial.setIcon(QtGui.QIcon(':/icons/Arch_Material_Group.svg'))
        editMaterial.setIconSize(g_icon_size)
        editMaterial.clicked.connect(self.on_pushButton_editMaterial)

        buttonGroupBox = QtGui.QGroupBox()
        buttonGroupBox.setFlat(True)
        buttonLayout = QtGui.QHBoxLayout()
        buttonLayout.addWidget(newSelection)
        buttonLayout.addWidget(save)
        buttonLayout.addWidget(export)
        buttonLayout.addWidget(readDensities)
        buttonLayout.addWidget(editMaterial)
        buttonGroupBox.setLayout(buttonLayout)
        margin = buttonLayout.contentsMargins()
        buttonLayout.setContentsMargins(0, margin.top(), 0, 0)

        self.mainGroupBox = QtGui.QGroupBox('Selected solids: 0')
        mainGroupLayout = QtGui.QVBoxLayout()
        mainGroupLayout.addWidget(scroll)
        mainGroupLayout.addWidget(buttonGroupBox)
        self.mainGroupBox.setLayout(mainGroupLayout)
        layout.addWidget(self.mainGroupBox)

        # cdgGroupBox
        label_CdG = QtGui.QLabel('Center of mass')

        self.resultCdG = []
        for axis in range(3):
            self.resultCdG.append(QtGui.QLineEdit(self))
            self.resultCdG[axis].setObjectName('center of mass')
            self.resultCdG[axis].setReadOnly(True)

        cdgLayout = QtGui.QHBoxLayout()
        cdgLayout.addWidget(label_CdG)
        for axis in range(3):
            cdgLayout.addWidget(self.resultCdG[axis])
        cdgGroupBox = QtGui.QGroupBox()
        cdgGroupBox.setLayout(cdgLayout)
        layout.addWidget(cdgGroupBox)

	# viewGroupBox
        showCoM = QtGui.QCheckBox(toolTip='Show center of mass')
        if self.doc.getObject('CenterOfMass'):
            showCoM.setChecked(True)
        showCoM.setIcon(QtGui.QIcon(':/icons/Std_ToggleVisibility.svg'))
        showCoM.setIconSize(g_icon_size)
        showCoM.stateChanged.connect(self.on_stateChanged_showCoM)

        self.switchVolumMass = QtGui.QPushButton('mass')
        self.switchVolumMass.setToolTip('switch radius of spheres to represent relative masses or volumes\nmass : Spheres Radius = object mass / total mass\nvolume : Sphere Radius = object volume / total volume')
        self.switchVolumMass.setIcon(QtGui.QIcon(':/icons/PartDesign_Boolean.svg'))
        self.switchVolumMass.setIconSize(g_icon_size)
        self.switchVolumMass.setCheckable(True)
        self.switchVolumMass.setChecked(True)
        self.switchVolumMass.setEnabled(False)
        self.switchVolumMass.clicked.connect(self.on_pushButton_switchVolumMass)

        self.changeRadius = QtGui.QSlider(QtGui.Qt.Horizontal)
        self.changeRadius.setToolTip('Change radius of spheres')
        self.changeRadius.setEnabled(False)
        self.changeRadius.setMaximum(49)
        self.changeRadius.valueChanged.connect(self.on_slideButton_changeRadius)

        self.checkColorify = QtGui.QCheckBox(toolTip='Color shapes depending on density')
        self.checkColorify.setIcon(QtGui.QIcon(':/icons/Std_RandomColor.svg'))
        self.checkColorify.setIconSize(g_icon_size)
        self.checkColorify.stateChanged.connect(self.on_stateChanged_Colorify)

        self.comboColormap = QtGui.QComboBox(toolTip='Colormap used for color shapes depending on density')
        #https://matplotlib.org/3.3.1/tutorials/colors/colormaps.html
        self.comboColormap.addItems(['autumn_r', 'cividis_r', 'coolwarm', 'RdYlBu_r', 'RdYlGn_r', 'summer_r', 'terrain', 'turbo', 'viridis_r', 'Wistia', 'YlGn'])
        self.comboColormap.setCurrentText(DEFAULT_COLORMAP)
        self.comboColormap.currentTextChanged.connect(self.on_comboColormap_changed)
        self.comboColormap.setEnabled(False)

        viewLayout = QtGui.QHBoxLayout()
        viewLayout.addWidget(showCoM)
        viewLayout.addWidget(self.switchVolumMass)
        viewLayout.addWidget(self.changeRadius)
        viewLayout.addWidget(self.checkColorify)
        viewLayout.addWidget(self.comboColormap)
        viewGroupBox = QtGui.QGroupBox('View')
        viewGroupBox.setToolTip('View selected objects and center of mass has spheres')
        viewGroupBox.setLayout(viewLayout)
        layout.addWidget(viewGroupBox)

        # massGroupBox
        label_Mass = QtGui.QLabel('Total mass')

        self.resultMass = QtGui.QLineEdit(self)
        self.resultMass.setObjectName('total weight')
        self.resultMass.setReadOnly(True)

        massLayout = QtGui.QHBoxLayout()
        massLayout.addWidget(label_Mass)
        massLayout.addWidget(self.resultMass)
        massGroupBox = QtGui.QGroupBox()
        massGroupBox.setLayout(massLayout)
        layout.addWidget(massGroupBox)

    def init_solids(self, objs):
        """Construct new items and compute"""
        self.find_all_centerOfMass(objs)
        for sol in range(self.solid_count):
            self.solids[sol] = SolidsWidget(
                parent=self,
                solid=g_sel[sol],
                sol=sol
            )
        self.mainGroupBox.setTitle('Selected solids: ' + str(self.solid_count))
        self.compute_centerOfMass()

    def valid_selection(self):
        """Get valid objects (Shape, Mesh) from selection"""
        def sort_selection_by_label(s_):
            return s_.Label

        def sort_selection_by_tree(s_):
            return self.tree_list.index(s_.Label)

        _sel = gui.Selection.getSelection()

        # Add contents of group objects 'groupObjs' (breadth-first search).
        # For PartDesign objects a Group contains recursive features.
        # Only nested App:Part are considered at this place.
        groupObjs = ['App::DocumentObjectGroup', 'App::GeometryPython']
        i_ = 0
        while i_ < len(_sel):
            if hasattr(_sel[i_], 'Group') and _sel[i_].TypeId in groupObjs:
                _sel.extend(_sel[i_].Group)
                del _sel[i_]
            elif hasattr(_sel[i_], 'Group') and _sel[i_].TypeId == 'App::Part':
                for gp in _sel[i_].Group:
                    if gp.TypeId == 'App::Part':
                        _sel.append(gp)
                i_ += 1    # where to look at the next run
            else:
                i_ += 1

        # create valid selection list
        vsel = []
        for s_ in _sel:
            if hasattr(s_, 'Shape') and s_.Shape.Volume:
                if s_.TypeId == 'App::Part':
                    # because contains bodies
                    csList = s_.Shape.childShapes(False,False)    # ignore placement of parent
                    for cs in range(len(csList)):
                        # get first match from OutList (contains different object types)
                        for ot in s_.OutList:
                            if hasattr(ot, 'Shape') and ot.Shape.isEqual(csList[cs]):
                                # nested App:Part and App:Link in App:Part not match here
                                vsel.append(ot)
                                break
                    # App:Link in App:Part
                    for ot in s_.OutList:
                        if ot.TypeId == 'App::Link':
                            vsel.append(ot)
                elif s_.TypeId == 'Part::FeaturePython' and hasattr(s_, 'IfcType'):
                    # e.g. Arch Wall/Structure, because can contain childs
                    vsel.append(s_)
                    for it in s_.InList[1:]:
                        # include childs (Windows etc.), parent is first InList
                        if it.TypeId == 'Part::FeaturePython' and it.Shape.Volume:
                            vsel.append(it)
                else:
                    vsel.append(s_)
            elif hasattr(s_, 'Mesh') and s_.Mesh.Volume:
                vsel.append(s_)

        # sort valid selection list or match up with tree view
        if SORT_SELECTION:
            vsel.sort(key=sort_selection_by_label)
        else:
            tree = g_main_window.findChild(QtGui.QTreeWidget)
            iterator = QtGui.QTreeWidgetItemIterator(tree, QtGui.QTreeWidgetItemIterator.Editable)
            # Syntax: [ EXP for x in seq if COND ]
            self.tree_list = [i_.value().text(0) for i_ in list(iterator)]
            vsel.sort(key=sort_selection_by_tree)

        # create valid objects list (e.g. shapes)
        import Part
        objs = []
        for i_ in range(len(vsel)):
            s_ = vsel[i_]
            if hasattr(s_, 'Shape'):
                # local placement correction (transform to global coordinate system)
                o_ = Part.getShape(s_)    # copy shape for transformation
                if callable(getattr(s_, 'getGlobalPlacement', None)):
                    o_.Placement = s_.getGlobalPlacement()
                else:
                    # e.g. App::Link has no method getGlobalPlacement
                    if s_.InList:
                        for it in s_.InListRecursive:
                            o_.Placement = o_.Placement.multiply(it.Placement)
                objs.append(o_)
            elif hasattr(s_, 'Mesh'):
                objs.append(s_.Mesh)
            # change vsel entry for special object cases
            if s_.TypeId == 'Part::FeaturePython' and hasattr(s_, 'ArrayType'):
                # e.g. Draft Arrays, because no ShapeColor etc. in ViewObject
                vsel[i_] = s_.OutList[0]

        if len(_sel) > len(vsel):
            app.Console.PrintWarning('Ignored invalid object from selection\n')
        if objs:
            global g_sel
            g_sel = vsel
            self.solid_count = len(objs)
        return objs

    def on_pushButton_newSelection(self):
        try:
            self.set_objects_transparent(False)
        except:
            pass
        objs = self.valid_selection()
        if not objs:
            return
        self.doc = app.activeDocument()
        # safe way to remove all items from layout
        while self.solidLayout.count():
            child = self.solidLayout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        self.init_solids(objs)

        if self.changeRadius.isEnabled():
            self.draw_centerOfMass()

    def load_materials(self):
        """Load density from material cards"""
        # Get resource paths
        fem_prefs = app.ParamGet("User parameter:BaseApp/Preferences/Mod/Material/Resources")
        use_built_in_materials = fem_prefs.GetBool("UseBuiltInMaterials", True)
        use_mat_from_config_dir = fem_prefs.GetBool("UseMaterialsFromConfigDir", True)
        use_mat_from_custom_dir = fem_prefs.GetBool("UseMaterialsFromCustomDir", True)
        custom_dir = fem_prefs.GetString("CustomMaterialsDir", "")
        # later found cards with same name will override cards
        resources = []
        if use_built_in_materials:
            # FreeCAD.getResourceDir() returns inconsistent path
            # (https://forum.freecadweb.org/viewtopic.php?t=32036)
            resources.append(os.path.join(
                os.path.normpath(app.getResourceDir()), "Mod", "Material", "StandardMaterial")
            )
        if use_mat_from_config_dir:
            resources.append(os.path.join(app.ConfigGet("UserAppData"), "Material"))
        if use_mat_from_custom_dir and custom_dir:
            resources.append(custom_dir)
        print('locations to look for material cards:')
        for path in resources:
            print('  ' + path)

        # Read material cards
        import importFCMat
        mat_cards = {}              # all material cards
        self.material_cards = {}    # with valid density
        for p in resources:
            if os.path.exists(p):
                for f in sorted(os.listdir(p)):
                    b, e = os.path.splitext(f)
                    if e.upper() == ".FCMAT":
                        mat_cards[b] = os.path.join(p, f)
        for mat_name in sorted(mat_cards):
            try:
                d = importFCMat.read(mat_cards[mat_name]).get('Density')
                if (len(d) > 1 and Units.Quantity(d).Value > 0):
                    self.material_base[mat_name] = Units.Quantity(d)
                    self.material_cards[mat_name] = mat_cards[mat_name]
            except:
                pass

    def on_pushButton_editMaterial(self):
        import MaterialEditor
        MaterialEditor.openEditor()
        self.load_materials()
        for sol in range(self.solid_count):
            for m in sorted(self.material_base):
                # add new materials
                if self.solids[sol].combo.findText(m) == -1:
                    self.solids[sol].combo.addItem(m)

    def store_prefered_units(self, txt):
        """Get units set as preference"""
        self.unitForD_text = txt
        self.unitForD = self.unitForD_text.replace('Â³', '^3')         # density
        self.unitForL = self.unitForD_text.split('/')[1].rstrip('Â³')  # length
        self.unitForM = self.unitForD_text.split('/')[0]              # mass
        self.unitForV = self.unitForD.split('/')[1]                   # volume

    def convert_length(self, length):
        """Convert length from internal FreeCAD to preference unit"""
        pq = Units.parseQuantity
        return float(pq('{} mm'.format(length)) / pq(self.unitForL))

    def convert_volume(self, volume):
        """Convert volume from internal FreeCAD to preference unit"""
        pq = Units.parseQuantity
        return float(pq('%f mm^3' % volume) / pq(self.unitForV))

    def on_comboUnitDensity_changed(self, newText):
        unitForD_prev = self.unitForD
        self.store_prefered_units(newText)
        for sol in range(self.solid_count):
            qty = str(self.solids[sol].spinDens.value()) + ' ' + unitForD_prev
            self.solids[sol].init_spinDensity(self.solids[sol].spinDens,
                                              Units.Quantity(qty),
                                              self.unitForD)
            self.solids[sol].spinDens.setToolTip(
                'density of ' + g_sel[sol].Label + ' (in ' + self.unitForD_text + ')')
            self.solids[sol].update_spinMass_only()
        qty = self.material_base.get('default', 0)
        SolidsWidget.init_spinDensity(self, self.defaultDensitySpin,
                                      Units.Quantity(qty),
                                      self.unitForD)
        self.defaultDensitySpin.setToolTip('set default density (in ' + self.unitForD_text + ')')
        self.compute_centerOfMass()

    def on_spinDefaultDensity_changed(self, newValue):
        qty = str(newValue) + ' ' + self.unitForD
        self.material_base['default'] = Units.Quantity(qty)

    def on_pushButton_allToDefaultDensity(self):
        for sol in range(self.solid_count):
            self.solids[sol].combo.setCurrentIndex(0)    # reset "default" to "custom"
            self.solids[sol].combo.setCurrentText('default')

    def find_all_centerOfMass(self, objs):
        """Find all center of mass (CoMs) depending on the type of object."""
        import DraftVecUtils
        self.solids = [0] * self.solid_count
        self.volumes = [0] * self.solid_count
        self.masses = [0] * self.solid_count
        self.CoMs = [app.Vector(0, 0, 0)] * self.solid_count

        # function is slower than valid_selection and compute_centerOfMass
        # because of .Volume and .CenterOfMass
        progress_bar = app.Base.ProgressIndicator()
        progress_bar.start('Finding center of mass ...', self.solid_count)
        for sol in range(self.solid_count):
            self.volumes[sol] = objs[sol].Volume
            if hasattr(objs[sol], 'CenterOfGravity'):
                # FreeCAD >= 0.20
                self.CoMs[sol] = objs[sol].CenterOfGravity
            elif hasattr(objs[sol], 'CenterOfMass'):
                # FreeCAD 0.19
                self.CoMs[sol] = objs[sol].CenterOfMass
            elif hasattr(objs[sol], 'Solids'):
                for array_sol in objs[sol].Solids:
                    if hasattr(array_sol, 'CenterOfGravity'):
                        self.CoMs[sol] += array_sol.CenterOfGravity
                    else:
                        self.CoMs[sol] += array_sol.CenterOfMass
                self.CoMs[sol] /= objs[sol].Solids.__len__()
            # estimate CoM of a mesh
            elif hasattr(objs[sol], 'Points'):
                _CoM = [0,0,0]
                for f in objs[sol].Facets:
                    currentVolume = (f.Points[0][0]*f.Points[1][1]*f.Points[2][2]
                        - f.Points[0][0]*f.Points[2][1]*f.Points[1][2]
                        - f.Points[1][0]*f.Points[0][1]*f.Points[2][2]
                        + f.Points[1][0]*f.Points[2][1]*f.Points[0][2]
                        + f.Points[2][0]*f.Points[0][1]*f.Points[1][2]
                        - f.Points[2][0]*f.Points[1][1]*f.Points[0][2]) / 6.
                    for ax in range(3):
                        _CoM[ax] += ((f.Points[0][ax] + f.Points[1][ax] + f.Points[2][ax]) / 4.
                                ) * currentVolume
                for ax in range(3):
                    _CoM[ax] /= self.volumes[sol]
                self.CoMs[sol] = app.Vector(*_CoM)            # Calculate BoundBox of all objects
            if sol == 0:
                self.boundBox = objs[sol].BoundBox
            else:
                self.boundBox = self.boundBox.united(objs[sol].BoundBox)
            progress_bar.next()
        progress_bar.stop()

    def compute_centerOfMass(self):
        """Compute joint center of mass from all objects."""
        self.massTot = 0.
        self.volTot = 0.
        self.TotalCoM = app.Vector(0,0,0)
        for sol in range(self.solid_count):
            volumeInUnit = self.convert_volume(self.volumes[sol])
            self.masses[sol] = volumeInUnit * self.solids[sol].spinDens.value()
            self.massTot += self.masses[sol]
            self.volTot += volumeInUnit
        for sol in range(self.solid_count):
            self.TotalCoM += 1 / self.massTot * self.masses[sol] * self.CoMs[sol]
        # output
        for axis in range(3):
            self.resultCdG[axis].setText('{:.4}'.format(self.convert_length(self.TotalCoM[axis])))
        self.resultCdG[0].setToolTip('center of mass X (in %s)' % self.unitForL)
        self.resultCdG[1].setToolTip('center of mass Y (in %s)' % self.unitForL)
        self.resultCdG[2].setToolTip('center of mass Z (in %s)' % self.unitForL)
        self.resultMass.setText('{:.6}'.format(self.massTot))
        self.resultMass.setToolTip('total weight (in %s)' % self.unitForM)
        if self.doc.getObject('CenterOfMass'):
            self.draw_centerOfMass()
        if self.checkColorify.isChecked():
            self.colorify()

    def draw_centerOfMass(self):
        boundBoxL = [self.boundBox.XLength, self.boundBox.YLength, self.boundBox.ZLength]
        self.doc = app.activeDocument()    # it is possible to draw in a different document
        try:
            CoMObjs = self.doc.getObject('CenterOfMass')
            CoMObjs.removeObjectsFromDocument()    # remove childs
        except:
            CoMObjs = self.doc.addObject('App::DocumentObjectGroup', 'CenterOfMass')

        # Local coordinate system at center of masses
        lcs = self.doc.addObject('PartDesign::CoordinateSystem', 'CoMLCS')
        lcs.Placement = app.Placement(app.Vector(*self.TotalCoM),app.Rotation(0,0,0))
        CoMObjs.addObject(lcs)

        # Sphere to represent the center of masses
        sphere = self.doc.addObject('Part::Sphere', 'CoMTotal')
        sphere.Placement.Base = app.Vector(*self.TotalCoM)
        sphere.ViewObject.ShapeColor = (0.6, 0.0, 0.0)
        sphere.ViewObject.LineWidth = 1.0
        CoMObjs.addObject(sphere)

        # Spheres for all center of mass
        if self.solid_count > 1:
            for sol in range(self.solid_count):
                sphere = self.doc.addObject('Part::Sphere', 'CoM_' + g_sel[sol].Name)
                sphere.Label = 'CoM_' + g_sel[sol].Label
                sphere.Placement.Base = app.Vector(*self.CoMs[sol])
#                sphere.ViewObject.ShapeColor = (1.0, 1.0, 1.0)
                sphere.ViewObject.ShapeColor = self.solids[sol].orgColorFC
                sphere.ViewObject.LineWidth = 1.0
                CoMObjs.addObject(sphere)

        # Planes with center of mass and size of boundBox
        cplane_name = ['CoMPlaneYZ', 'CoMPlaneXZ', 'CoMPlaneXY']
        cplane_norm = [app.Vector(1.,0.,0.),
                       app.Vector(0.,1.,0.),
                       app.Vector(0.,0.,1.)]
        cplane_rot  = [app.Rotation(0,-90,  0),
                       app.Rotation(0,  0, 90),
                       app.Rotation(0,  0,  0)]
        cplane_lewi =[[boundBoxL[2],boundBoxL[1]],
                      [boundBoxL[0],boundBoxL[2]],
                      [boundBoxL[0],boundBoxL[1]]]
        for axis in range(3):
            plane = self.doc.addObject('Part::Plane', cplane_name[axis])
            plane.Length = cplane_lewi[axis][0]
            plane.Width  = cplane_lewi[axis][1]
            plane.Placement = app.Placement(app.Vector(*self.TotalCoM),cplane_rot[axis])
            for axi2 in range(3):
                 plane.Placement.move(cplane_norm[axi2] * boundBoxL[axi2] /-2.)
            plane.Placement.move(     cplane_norm[axis] * boundBoxL[axis] /2.)
            color = list(cplane_norm[axis])
            plane.ViewObject.LineColor = (*color, 0.)    # rgba
            plane.ViewObject.LineWidth = 1.0
            plane.ViewObject.Transparency = 100
            CoMObjs.addObject(plane)

        ### BoundingBox
        BBoxSolid = self.doc.addObject("Part::Box","CoMBBox")
        BBoxSolid.Placement.Base = self.boundBox.Center.sub(app.Vector(boundBoxL).multiply(0.5))
        BBoxSolid.Length = boundBoxL[0]
        BBoxSolid.Width  = boundBoxL[1]
        BBoxSolid.Height = boundBoxL[2]
        BBoxSolid.ViewObject.Transparency = 90
        BBoxSolid.ViewObject.ShapeColor = (0.5, 0.5, 0.5)
#        BBoxSolid.ViewObject.BoundingBox = True
        CoMObjs.addObject(BBoxSolid)

        self.draw_update_sphere_radius()
        self.set_objects_transparent(True)
        self.doc.recompute()
        self.changeRadius.setEnabled(True)
        self.switchVolumMass.setEnabled(True)

    def draw_update_sphere_radius(self):
        boundBoxL = [self.boundBox.XLength, self.boundBox.YLength, self.boundBox.ZLength]
        radiusCOM = (1+self.changeRadius.value())/100.

        # Sphere to represent the center of masses
        sphere = self.doc.getObject('CoMTotal')
        if hasattr(sphere, 'Radius'):
            sphere.Radius = radiusCOM * max(boundBoxL)

        # Spheres for all center of mass
        for sol in range(self.solid_count):
            sphere = self.doc.getObject('CoM_' + g_sel[sol].Name)
            if hasattr(sphere, 'Radius'):
                if g_relative_radius == 'mass':
                    sphere.Radius = radiusCOM * max(boundBoxL) * math.pow(self.masses[sol]/self.massTot, 1./3.)
                else:
                    sphere.Radius = radiusCOM * max(boundBoxL) * math.pow(self.convert_volume(self.volumes[sol])/self.volTot, 1./3.)

        self.doc.recompute()

    def set_objects_transparent(self, transparent):
        if transparent:
            for sol in range(self.solid_count):
                g_sel[sol].ViewObject.Transparency = 25
        else:
            for sol in range(self.solid_count):
                g_sel[sol].ViewObject.Transparency = self.solids[sol].orgTransparency

    def on_stateChanged_showCoM(self, state):
        if state == QtCore.Qt.Checked:
            self.draw_centerOfMass()
        else:
            self.changeRadius.setEnabled(False)
            self.switchVolumMass.setEnabled(False)
            try:
                self.set_objects_transparent(False)
                self.doc.getObject('CenterOfMass').removeObjectsFromDocument()
                self.doc.removeObject('CenterOfMass')
            except:
                pass

    def on_pushButton_switchVolumMass(self,state):
        global g_relative_radius
        if state == True:
            g_relative_radius = 'mass'
        else:
            g_relative_radius = 'volume'

        self.switchVolumMass.setText(g_relative_radius)
        self.draw_update_sphere_radius()

    def on_slideButton_changeRadius(self):
        self.draw_update_sphere_radius()

    def on_stateChanged_Colorify(self, state):
        if state == QtCore.Qt.Checked:
            self.colorify()
            self.comboColormap.setEnabled(True)
        else:
            self.comboColormap.setEnabled(False)
            for sol in range(self.solid_count):
                self.doc.getObject(g_sel[sol].Name).ViewObject.ShapeColor = self.solids[sol].orgColorFC
                self.solids[sol].spinDens.setStyleSheet('QDoubleSpinBox {background-color: transparent}')
                if self.doc.getObject('CenterOfMass'):
                    self.doc.getObject('CoM_' + g_sel[sol].Name).ViewObject.ShapeColor = self.solids[sol].orgColorFC

    def colorify(self):
        import matplotlib 
        cm = matplotlib.cm.get_cmap(self.comboColormap.currentText())

        pq = Units.parseQuantity
        densityConverted = []
        for sol in range(self.solid_count):
            density = self.solids[sol].spinDens.value()
            densityConverted.append(float(pq('%f %s' % (density, self.unitForD)) / pq('kg/m^3')))
        maxD = max(densityConverted)
        minD = min(densityConverted)
        for sol in range(self.solid_count):
            if maxD == minD:
                drel = 0.5
            else:
                # density value to colormap color range
                drel = (densityConverted[sol]-minD) / (maxD-minD)
                drel = math.acos(1-2*drel) / math.pi    # non-linear relation to stretch the middle color
            color = QtGui.QColor.fromRgbF(cm(drel)[0], cm(drel)[1], cm(drel)[2])
            self.doc.getObject(g_sel[sol].Name).ViewObject.ShapeColor = color.getRgbF()
            self.solids[sol].spinDens.setStyleSheet('QDoubleSpinBox {background-color: %s}' %color.name())
            if self.doc.getObject('CenterOfMass'):
                self.doc.getObject('CoM_' + g_sel[sol].Name).ViewObject.ShapeColor = color.getRgbF()

    def on_comboColormap_changed(self, newText):
        self.colorify()

    def on_pushButton_toPreferences(self):
        gui.runCommand('Std_DlgParameter',0)

    def on_pushButton_Save(self):
        for sol in range(self.solid_count):
            mat_selected = self.solids[sol].combo.currentText()
            if mat_selected == 'default':
                # remove properties set by this macro
                g_sel[sol].removeProperty('Mat_Name')
                g_sel[sol].removeProperty('Mat_Density')
            else:
                # Material Name
                tip = ['Custom', 'set by CenterOfMass Macro']
                if not hasattr(g_sel[sol], 'Mat_Name'):
                    g_sel[sol].addProperty('App::PropertyString', 'Mat_Name', *tip)
                g_sel[sol].Mat_Name = mat_selected
                # Density
                if not hasattr(g_sel[sol], 'Mat_Density'):
                    g_sel[sol].addProperty('App::PropertyString', 'Mat_Density', *tip)
                g_sel[sol].Mat_Density = str(self.solids[sol].spinDens.value()) + ' ' + self.unitForD
        Gui.SendMsgToActiveView("SaveAs")    # do not overwrite user's model directly

    def on_pushButton_Export(self):
        densTot = 0.
        if self.volTot:
            densTot = self.massTot/self.volTot
        fileName = ''
        fileName, Filter = QtGui.QFileDialog.getSaveFileName(self,
            'Export values',
            os.path.expanduser('~'),
            'CSV (Tab-separated) (*.csv);;Text (Tab-separated) (*.txt)')
        if fileName == '':
            app.Console.PrintWarning('no file saved \n')
        else:
            app.Console.PrintMessage('Saving ' + fileName + '\n')
            delimiter = '\t'
            head = ['Number', 'Label', 'Material',
                    'Volume (%s)'%self.unitForV, 'Density (%s)'%self.unitForD, 'Weight (%s)'%self.unitForM,
                    'Center of mass X (%s)'%self.unitForL, 'Center of mass Y (%s)'%self.unitForL ,'Center of mass Z (%s)'%self.unitForL]
            foot = ['Total', '', '',
                    '%.6e'%self.volTot, '%.6e'%densTot, '%.6e'%self.massTot,
                  *('%.6e'%self.convert_length(self.TotalCoM[axis]) for axis in range(3))]
            try:
                f = open(fileName, 'w', encoding="utf-8")
                f.write(delimiter.join(head) + '\n')
                for sol in range(self.solid_count):
                    row = ['%d'%(sol + 1), '%s'%g_sel[sol].Label, '%s'%self.solids[sol].combo.currentText(),
                           '%.6e'%self.convert_volume(self.volumes[sol]), '%.6e'%self.solids[sol].spinDens.value(), '%.6e'%self.masses[sol],
                         *('%.6e'%self.convert_length(self.CoMs[sol][axis]) for axis in range(3))]
                    f.write(delimiter.join(row) + '\n')
                f.write(delimiter.join(foot))
                f.close()
                app.Console.PrintMessage(fileName + ' saved \n')
            except:
                error_message('Error writing file ' + fileName)

    def on_pushButton_Import(self):
        fileName, Filter = QtGui.QFileDialog.getOpenFileName(self,
            'Open file',
            os.path.expanduser('~'),
            'CSV (Tab-separated) (*.csv);;Text (Tab-separated) (*.txt)')
        if fileName:
            selList = [0] * self.solid_count
            # name list of selected solids
            for sol in range(self.solid_count):
                selList[sol] = g_sel[sol].Label
            with open(fileName, 'r', encoding='utf-8') as csvfile:
                app.Console.PrintMessage('Reading from %s\n' % fileName)
                reader = csv.DictReader(csvfile, delimiter='\t')
                matLoaded = 0
                # Syntax: [ EXP for x in seq if COND ]
                nameOfDensityCol = next((s for s in reader.fieldnames if 'density' in s.lower()), None)
                try:
                    # Extract unit between brackets
                    unitForD = nameOfDensityCol.split('(')[1].split(')')[0]
                except:
                    unitForD = self.unitForD
                for row in reader:
                    if row['Label'] in selList:
                        sol = selList.index(row['Label'])
                        try:
                            self.solids[sol].combo.setCurrentText(row['Material'])
                        except:
                            app.Console.PrintWarning('Unknown material or unable to find a '
                                + '"Material" column in the file --> Material set to "custom"')
                            self.solids[sol].combo.setCurrentText('custom')
                        if self.solids[sol].combo.currentText() == 'custom':
                            try:
                                qty = row[nameOfDensityCol] + ' ' + unitForD
                                self.solids[sol].spinDens.setValue(
                                    Units.Quantity(qty).getValueAs(self.unitForD))
                            except:
                                self.solids[sol].combo.setCurrentText('default')
                                app.Console.PrintWarning('Unable to find a "Density" column '
                                    + 'in the file --> Material set to "default"')
                        matLoaded += 1
                app.Console.PrintMessage(str(matLoaded) + ' materials loaded')


def valid_density_string(string):
    valid = False
    try:
        if Units.Quantity(string).Unit.Type == 'Density':
            valid = True
    except:
        pass
    return valid

def error_message(msg, choice):
    app.Console.PrintError(msg + '\n')
    QtGui.QMessageBox.critical(g_main_window, 'Error', msg)


if __name__ == '__main__':
    if not valid_density_string(DEFAULT_DENSITY):
        app.ParamGet(MACRO_SETTINGS).RemString('Default density')
        error_message('Default density user parameter was set wrong. Try again.', 0)
    else:
        print('Loading ' + __Name__ + ' ' + __Version__ + ' ...')
        gui.updateGui()
        if DOCKED_WINDOW:
            myWidget = CenterofmassDock()
        else:
            myWidget = CenterofmassWindow()